# FuckBase アーキテクチャ設計

このドキュメントでは、FuckBaseの内部アーキテクチャと実装の詳細について説明します。

## 全体構造

FuckBaseは以下の主要コンポーネントで構成されます：

```
FuckBase
├── HTTPサーバー
├── データベースマネージャ
│   ├── データベース1
│   │   ├── Set1
│   │   ├── Set2
│   │   └── インデックス
│   └── データベース2
├── S3コネクタ
├── 認証マネージャ
└── サーバー設定マネージャ
```

## コアコンポーネント

### HTTPサーバー

- Goの標準ライブラリまたはフレームワーク（例：Gin, Echo）を使用
- すべてのAPIエンドポイントを処理
- リクエストの検証と適切なコンポーネントへの転送
- エラーハンドリングとレスポンス生成

### データベースマネージャ

- 複数のデータベースインスタンスを管理
- データベースの作成、削除、アクセス制御
- 並行アクセスの制御（ミューテックス/RWロック）

### データベース

- 複数のSetとインデックスを管理
- トランザクション管理（オプション）
- メタデータの保持

### Set

- キーバリューペアの保存
- 内部的にはGoのmap（`map[string][]byte`）を使用
- バリューはMessagePackでエンコードされたバイト配列

### インデックス

- Setのデータに対する二次インデックス
- 形式: `map[string][]string`（値からキーのリストへのマッピング）
- ソート機能のサポート

### S3コネクタ

- S3互換ストレージとの連携
- バックアップと復元の処理
- 非同期処理のサポート

### 認証マネージャ

- ユーザー認証の処理
- アクセス制御の実施
- 管理者認証と一般ユーザー認証の区別

### サーバー設定マネージャ

- コマンドラインオプションの解析
- 環境変数の処理
- サーバー全体の設定管理

## データ構造

### サーバー設定構造体

```go
type ServerConfig struct {
    Port            int
    Host            string
    DataDir         string
    AdminAuth       *AdminAuthConfig
    S3Config        *S3Config
    LogLevel        string
    LogFile         string
    BackupInterval  int
}
```

### 管理者認証設定構造体

```go
type AdminAuthConfig struct {
    Username  string
    Password  string
    Enabled   bool
}
```

### S3設定構造体

```go
type S3Config struct {
    Endpoint    string
    Bucket      string
    AccessKey   string
    SecretKey   string
    Region      string
    Enabled     bool
}
```

### データベース構造体

```go
type Database struct {
    Name      string
    Sets      map[string]*Set
    Indexes   map[string]*Index
    Auth      *AuthConfig
    mu        sync.RWMutex
}
```

### Set構造体

```go
type Set struct {
    Name      string
    Data      map[string][]byte  // キーからMessagePackエンコードされた値へのマップ
    mu        sync.RWMutex
}
```

### インデックス構造体

```go
type Index struct {
    Name      string
    SetName   string
    Field     string
    Values    map[string][]string  // インデックス値からキーのリストへのマップ
    mu        sync.RWMutex
}
```

### データベース認証設定

```go
type AuthConfig struct {
    Username  string
    Password  string
    Enabled   bool
}
```

## 主要な処理フロー

### サーバー起動フロー

1. コマンドラインオプションと環境変数を解析
2. サーバー設定を初期化
3. データベースマネージャを初期化
4. S3コネクタを初期化（設定されている場合）
5. 認証マネージャを初期化
6. HTTPサーバーを起動
7. 自動バックアップスケジューラを開始（設定されている場合）

### 管理者認証フロー

1. HTTPリクエストを受信
2. リクエストが管理操作（データベース作成/削除など）かどうかを確認
3. 管理者認証が必要な操作の場合：
   a. リクエストヘッダーまたはボディから管理者認証情報を抽出
   b. 管理者認証情報を検証
   c. 認証失敗の場合はエラーレスポンスを返す
4. 認証成功または不要な場合は処理を続行

### データベース認証フロー

1. HTTPリクエストを受信
2. リクエストからデータベース名を抽出
3. 対象のデータベースに認証が設定されているか確認
4. 認証が必要な場合：
   a. リクエストヘッダーまたはボディから認証情報を抽出
   b. データベースの認証情報と照合
   c. 認証失敗の場合はエラーレスポンスを返す
5. 認証成功または不要な場合は処理を続行

### データ挿入フロー

1. HTTPリクエストを受信
2. リクエストを検証
3. 対象のデータベースとSetを特定
4. 値をMessagePackにエンコード
5. Setにデータを保存
6. 関連するインデックスを更新
7. 成功レスポンスを返す

### インデックス作成フロー

1. HTTPリクエストを受信
2. リクエストを検証
3. 対象のデータベースとSetを特定
4. 新しいインデックス構造体を作成
5. Setの全データをスキャン
   a. 各エントリのMessagePackデータをデコード
   b. 指定されたフィールドの値を抽出
   c. インデックスマップに追加
6. インデックスを保存
7. 成功レスポンスを返す

### インデックスクエリフロー

1. HTTPリクエストを受信
2. リクエストを検証
3. 対象のデータベース、Set、インデックスを特定
4. インデックスから指定された値に対応するキーのリストを取得
5. ソート条件に従ってキーをソート
6. ページネーションパラメータ（limit, offset）を適用
7. 各キーに対応する値を取得
8. 結果をレスポンスとして返す

### S3バックアップフロー

1. HTTPリクエストを受信またはスケジュールされたバックアップをトリガー
2. 管理者認証（設定されている場合）
3. 対象のデータベースを特定
4. データベースの読み取りロックを取得
5. データベースの状態をシリアライズ
6. S3に保存
7. 読み取りロックを解放
8. 成功レスポンスを返す

## 並行処理と同期

- 各データベース、Set、インデックスは独自のミューテックスを持つ
- 読み取り操作には`RLock`、書き込み操作には`Lock`を使用
- デッドロックを防ぐために、常に同じ順序でロックを取得

## エラーハンドリング

- すべての操作は適切なエラーチェックを行う
- エラーは適切なHTTPステータスコードとともに返される
- 内部エラーはログに記録される

## パフォーマンス最適化

### メモリ使用量

- 大きなデータセットの場合、メモリ使用量を監視
- 必要に応じてガベージコレクションをトリガー

### インデックス最適化

- インデックスの更新は効率的に行う
- 大量のデータに対するインデックス作成は非同期で行うオプションを検討

### 並列処理

- 独立した操作は並列に実行
- Goのgoroutineとチャネルを活用

## テスト戦略

### ユニットテスト

- 各コンポーネントの機能を個別にテスト
- モックを使用して依存関係を分離

### 統合テスト

- コンポーネント間の相互作用をテスト
- エンドツーエンドのシナリオをテスト

### ベンチマーク

- 主要な操作のパフォーマンスを測定
- 最適化の効果を検証